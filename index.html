<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>MindGapper.js</title>
        <script src="lib/d3/d3.js"></script>
        <script src="lib/d3/d3.csv.js"></script>
        <script src="html5slider.js"></script>
        <script type="text/javascript">

window.onload = function() {

  var uniqueCountries = {},
      countries = [],
      minGDP,
      maxGDP,
      minLE,
      maxLE,
      minYear,
      maxYear,
      minPOP,
      maxPOP,
      years;

  var GDP = {},
      countriesWithGDP = [],
      yearsWithGDP = [];

  var LE = {},
      countriesWithLE = [],
      yearsWithLE = [];
      
  var POP = {},
      countriesWithPOP = [],
      yearsWithPOP = [];

  var numLoaded = 0;  
  function checkLoaded() {
    numLoaded++;
    if (numLoaded == 4) {
      mergeData();
      initControls(); 
      initAxes();
      // go!
      renderAxes();
      renderLegend();
      renderMap();
      renderCountries();
      renderChart();      
    }
  }
  
  function parseTable(data, countries, years) {
    return function(csv) {
      var rows = d3.csv.parseRows(csv),
          theYears = rows[0].slice(1).map(Number);
      for (var y = 0; y < theYears.length; y++) {
        years.push(theYears[y]);
      }
      for (var i = 1; i < rows.length; i++) {
        var row = rows[i],
            country = row[0],
            values = row.slice(1).map(Number);
        // TODO: interpolate zero values? WWGMD?
        if (values.length > 0) {
          while (values.length < years.length) {
            // pad to years.length
            values.push(0);
          }
          countries.push(country);
          data[country] = values;
        }
      }
      checkLoaded();
    }
  }

  d3.text('data/gdp_per_capita_ppp.csv',             parseTable(GDP, countriesWithGDP, yearsWithGDP));
  d3.text('data/life_expectancy_at_birth.csv',       parseTable(LE,  countriesWithLE,  yearsWithLE));
  d3.text('data/indicator_gapminder_population.csv', parseTable(POP, countriesWithPOP, yearsWithPOP));

  var colors = [ '#3F4FFF', '#2FBFE5', '#68FF5E', '#E5FF2F', '#FF982F', '#FF2F2F' ],
      regions = [];
      countryRegions = {};

  d3.text('data/color_regions.csv', function(csv) {
    var rows = d3.csv.parseRows(csv),
        uniqueRegions = {};
    for (var i = 1; i < rows.length; i++) {
      var row = rows[i],
          country = row[0],
          region = row[1];
      if (!(region in uniqueRegions)) {
        uniqueRegions[region] = true;
        regions.push(region);
      }
      countryRegions[country] = region;
    }
    checkLoaded();
  });  
      
  function mergeData() {

    // the years are the same for the GDP and LE files:
    years = yearsWithLE;
    minYear = Math.min.apply(null, years);
    maxYear = Math.max.apply(null, years);
    
    // countries aren't the same, so let's find the unique ones
    function rememberUnique(country) { 
        if (country in uniqueCountries) {
            return;
        }
        uniqueCountries[country] = true;
        countries.push(country);
    };
    countriesWithLE.forEach(rememberUnique);
    countriesWithGDP.forEach(rememberUnique);
    countriesWithPOP.forEach(rememberUnique);
    countries.sort();    
    
    // and filter ones that don't have data in both
    countries = countries.filter(function(name) {
        return (name in LE) && (name in GDP) && (name in POP);
    });

    // measure GDP and LE and POP:
    minGDP = maxGDP = GDP[countries[0]][0];
    minLE = maxLE = LE[countries[0]][0];
    minPOP = maxPOP = POP[countries[0]][0];
    countries.forEach(function(country) {
      for (var i in GDP[country]) {
        minGDP = Math.min(minGDP, GDP[country][i]);
        maxGDP = Math.max(maxGDP, GDP[country][i]);
      }
      for (var i in LE[country]) {
        minLE = Math.min(minLE, LE[country][i]);
        maxLE = Math.max(maxLE, LE[country][i]);
      }
      for (var i in POP[country]) {
        minPOP = Math.min(minPOP, POP[country][i]);
        maxPOP = Math.max(maxPOP, POP[country][i]);
      }
    });
    
    // TODO: better padding!
    minGDP = 300;
    maxLE = 85;
    minLE = 10;  
  }
  
  var slider, playButton, yearDiv;
  
  function initControls() {  
  
    slider = document.getElementById('slider');
    playButton = document.getElementById('play');
    yearDiv = document.getElementById('year');
    
    slider.min = minYear;
    slider.max = maxYear;
    slider.value = maxYear;
    slider.step = 0.25;
    slider.onchange = function() {
      if (interval) {
        clearInterval(interval);
        interval = 0;
        playButton.innerHTML = '&#9654; Play';
      }        
//      console.profile('renderChart');
      renderChart();
//      console.profileEnd('renderChart');
    }
    
    playButton.onclick = animate;

  }
   
  var interval = 0;
  
  function animate() {
    if (interval) {
      clearInterval(interval);
      interval = 0;
      playButton.innerHTML = '&#9654; Play';
      return;
    }
    playButton.innerHTML = '&#9724; Stop';
    var slider = document.getElementById('slider')
        min = Number(slider.min),
        max = Number(slider.max);
    slider.value = min;
    interval = setInterval(function() {
      var value = Number(slider.value);
      if (value < max) {
        slider.value = value+0.25;
        renderChart();
      }
      else {
        clearInterval(interval);
        interval = 0;
        playButton.innerHTML = '&#9654; Play';
      }
    }, 25);
  }  
  
  var chart, xs, ys, rs;
  
  function initAxes() {

    chart = document.getElementById('chart');

    var chartX = 40,
        chartY = 5,
        chartWidth = chart.width-40,
        chartHeight = chart.height-40;

    xs = d3.scale.log()
            .domain([minGDP,maxGDP])
            .range([chartX,chartX+chartWidth]);

    ys = d3.scale.linear()
            .domain([minLE,maxLE])
            .range([chartY+chartHeight, chartY]);

    rs = d3.scale.sqrt()
            .domain([minPOP,maxPOP])
            .range([1.5,25]);
  
  }
  
  /// hat-tip http://jsfromhell.com/array/search
  function search(o, v, i){
    var h = o.length, l = -1, m;
    while(h - l > 1)
      if(o[m = h + l >> 1] < v) l = m;
      else h = m;
    return o[h] != v ? i ? h : -1 : h;
  } 
  
  function findBest(year,years,values) {
    var index = search(years,year,true);
    if (year == years[index] && values[index] != 0) {
      return values[index];
    }
    var lowerIndex = Math.max(0,index-1);
    var lower = values[lowerIndex];
    while (lower == 0 && lowerIndex > 0) {
      lowerIndex--;
      lower = values[lowerIndex]    
    }
    var higherIndex = index;
    var higher = values[higherIndex];
    while (higher == 0 && higherIndex < values.length-1) {
      higherIndex++;
      higher = values[higherIndex]    
    }
    if (higher == 0) {
      // use the last known value
      return lower;
    }
    if (lower == 0) {
      // skip data that would need extrapolating back in time    
      return NaN;
    }
    var lowYear = years[lowerIndex];
    var highYear = years[higherIndex];
    var p = (year-lowYear) / (highYear-lowYear);
    var value = lower + (higher-lower)*p;
//    if (isNaN(value)) {
//      console.log(index,lowerIndex,higherIndex,lower,higher,lowYear,highYear,p);
//    }
    return value;
  }
    
  function renderAxes() {
    var axes = document.getElementById('axes'),
        ctx = axes.getContext('2d');
    
    ctx.clearRect(0,0,axes.width,axes.height);
    
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 0.5;

    var xRange = xs.range(),
        yRange = ys.range();
    
    // 1px lines need 0.5px offset in <canvas>, grr.
    ctx.moveTo(xRange[0]+0.5,yRange[0]);
    ctx.lineTo(xRange[0]+0.5,yRange[1]);
    ctx.stroke();
    ctx.moveTo(xRange[0],yRange[1]+0.5);
    ctx.lineTo(xRange[1],yRange[1]+0.5);
    ctx.stroke();  
    
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#444';

    ys.ticks(20).forEach(function(v) {
        var axisY = 0.5+Math.floor(ys(v));
        ctx.moveTo(xRange[0],axisY);
        ctx.lineTo(xRange[1],axisY);
        ctx.stroke();    
        ctx.fillText(v, xRange[0] - 3, axisY)
    });
    
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillStyle = '#444';

    xs.ticks().forEach(function(v) {
        var axisX = 0.5+Math.floor(xs(v));
        ctx.moveTo(axisX,yRange[0]);
        ctx.lineTo(axisX,yRange[1]);
        ctx.stroke();
        var a = Math.log(v) / Math.LN10;
        if (Math.abs(a - Math.round(a)) < 0.001) {
            ctx.fillText(v, axisX, yRange[0] + 3);
        }
    });

    ctx.save();
    ctx.translate(5,(yRange[0]+yRange[1])/2);
    ctx.rotate(-Math.PI*0.5);
    ctx.fillText('Life expectancy (years) (lin)', 0, 0);
    ctx.restore();
    
    ctx.fillText('Income per person (GDP/capita, PPP$ inflation-adjusted) (log)', (xRange[0]+xRange[1])/2, yRange[0]+15);
  
  }

  function renderCountries() {
    var select = document.getElementById('countrylist');
    countries.forEach(function(country) {
      var label = document.createElement('label');
      label.setAttribute('for', country);
      var input = document.createElement('input');
      input.setAttribute('name', country);
      input.setAttribute('type', 'checkbox');
      label.appendChild(input);
      label.appendChild(document.createTextNode(country));
      select.appendChild(label);
    });
  }

  function renderMap() {
  
    var canvas = document.getElementById('map'),
        ctx = canvas.getContext('2d'),
        w = canvas.width,
        h = canvas.height;

    ctx.clearRect(0,0,w,h);

    var img = new Image();
    img.onload = function() {
      ctx.drawImage(img,0,h-img.height);
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillStyle = '#444';
      ctx.fillText('Color: geographic regions', 0, 0);
    }
    img.src = 'map/world.png';
    
  }
  
  function renderLegend() {
    var canvas = document.getElementById('bubblelegend'),
        ctx = canvas.getContext('2d'),
        w = canvas.width,
        h = canvas.height;

    var minRadius = 1.5,
        maxRadius = 25 + minRadius;
  
    ctx.clearRect(0,0,w,h);
    
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillStyle = '#444';
    ctx.fillText('Size: population, total', 0, 0);
    
    ctx.strokeStyle = '#888';    
    ctx.beginPath();
    ctx.moveTo(0, h-0.5);
    ctx.lineTo(w, h-0.5);
    ctx.stroke();

    ctx.strokeStyle = '#888';
    ctx.fillStyle = '#ddd';

    ctx.beginPath();
    ctx.arc(maxRadius, h-0.5, maxRadius, 0, Math.PI, true);
    ctx.fill();
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(minRadius, h-0.5, minRadius, 0, Math.PI, true);
    ctx.fill();
    ctx.stroke();

    ctx.textAlign = 'left';
    ctx.textBaseline = 'bottom';
    ctx.fillStyle = '#444';
    ctx.fillText(formatPop(minPOP), 2*minRadius, h);
    ctx.fillText(formatPop(maxPOP), 2*maxRadius, h);
    
  }
  
  function formatPop(n) {
    if (n > 1000000000) {
      return (n / 1000000000).toFixed(2) + "B";
    }
    else if (n > 1000000) {
      return (n / 1000000).toFixed(2) + "M";
    }
    return n.toFixed(2);
  }
    
  function renderChart() {
  
    var year = Number(slider.value);
    
    yearDiv.innerHTML = year.toFixed();

    var ctx = chart.getContext('2d');    
    ctx.clearRect(0,0,chart.width,chart.height);
    
    var circles = countries.map(function(country) {
      var gdp = findBest(year,yearsWithGDP,GDP[country]),
           le = findBest(year,yearsWithLE,LE[country]),
          pop = findBest(year,yearsWithPOP,POP[country]),
            r = rs(pop),
            c = colors[regions.indexOf(countryRegions[country])];
      // skip data that would need extrapolating back in time
      if ((isNaN(le) || isNaN(gdp) || isNaN(pop))) {
        r = 0;
      }
      return { x: xs(gdp), y: ys(le), r: r, c: c };
    });
    
    circles.sort(function(b,a) { return a.r < b.r ? -1 : a.r > b.r ? 1 : 0; });

    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 1.0;

    circles.forEach(function(c) {
      ctx.fillStyle = c.c;
      ctx.beginPath();
      ctx.arc(c.x,c.y,c.r,0,2*Math.PI,true);
      ctx.fill();
      ctx.stroke();
    });
    
  }
  
} // window.onload

        </script>
        <style type="text/css">
body {
    margin: 0;
    padding: 50px;
    background: #fff;
    color: #222;
    font-family: Helvetica, Arial, sans-serif;
}
h1, h2, #container, #controls, p {
    margin: 0px 0px 20px 0px;
}
h1, h2 {
    color: #666;
}
p {
    width: 600px;
    margin-top: 25px;
}
hr {
    margin: 25px 0 0 0;
    width: 600px;
}
#container {
    position: relative;
    display: block;
    width: 600px;
    height: 400px;
}
#chart, #axes {
    display: block;
    position: absolute;
    left: 0;
    top: 0;
}
#bubblelegend {
    display: block;
    position: absolute;
    left: 610px;
    bottom: 35px;
}
#map {
    display: block;
    position: absolute;
    left: 610px;
    top: 5px;
}
#countrylist {
    display: block;
    position: absolute;
    left: 610px;
    top: 110px;
    width: 125px;
    height: 195px;
    overflow-x: hidden;
    overflow-y: scroll;
    padding: 0;
    margin: 0;
    border: 0;
}
#countrylist label {
    font-size: 11px;
    color: #222;
    width: 250px;
    display: block;
}
h2#year {
    display: block;
    position: absolute;
    left: 0;
    top: 0;
    width: 560px;
    height: 395px;
    color: #eee;
    vertical-align: middle;
    text-align: center;
    font-size: 244px;
    line-height: 400px;
    margin: 5px 0 0 40px;
    padding: 0;
}
#controls input, #controls button {
    vertical-align: middle;
}
#slider {
    width: 500px;
}
#play {
    width: 80px;
    text-align: center;
    margin: 0px 10px;
}
        </style>
    </head>
    <body>
        <h1>MindGapper</h1>
        <h2>Wealth &amp; Health of Nations</h2>
        <div id="container">
            <h2 id="year">year</h2>
            <canvas id="axes" width="600" height="400"></canvas>
            <div id="dots"></div>
            <canvas id="chart" width="600" height="400"></canvas>
            <canvas id="map" width="125" height="95"></canvas>
            <div id="countrylist"></div>
            <canvas id="bubblelegend" width="125" height="50"></canvas>
        </div>
        <div id="controls">
            <button id="play">&#9654; Play</button><input type="range" id="slider">
        </div>  
        <hr>
        <p>With much love and respect for <a href="http://www.gapminder.org/world/">Gapminder World</a>, 
          where you'll find more comprehensive data, full attributions, legends, tooltips, animation trails and 
          <a href="http://www.gapminder.org/GapminderMedia/wp-uploads/tutorial/Gapminder_World_Guide.pdf">much more</a>.</p>
        <p>It's easy to overlook <a href="http://www.gapminder.org/documentation/documentation/gapdoc003.pdf">the amount 
          of work</a> that goes into making something look simple. Wow.</p>
        <hr>
        <p>Made by Tom Carden, <a href="mailto:tom@bloom.io">tom@bloom.io</a>, March 2011.</p>
    </body>
</html>
